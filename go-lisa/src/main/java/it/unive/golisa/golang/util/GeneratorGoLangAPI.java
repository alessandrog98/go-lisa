package it.unive.golisa.golang.util;

import it.unive.golisa.golang.api.signature.ConstGoLangApiSignature;
import it.unive.golisa.golang.api.signature.FuncGoLangApiSignature;
import it.unive.golisa.golang.api.signature.GoLangApiSignature;
import it.unive.golisa.golang.api.signature.MethodGoLangApiSignature;
import it.unive.golisa.golang.api.signature.TypeGoLangApiSignature;
import it.unive.golisa.golang.api.signature.VarGoLangApiSignature;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

//TODO: to use during the GoLiSA build in order to generate Go Classes
public class GeneratorGoLangAPI {

	private static final Logger log = LogManager.getLogger(GeneratorGoLangAPI.class);

	private static final String DEFAULT_GO_API_FOLDER = "go-api";

	public static void main(String args[]) {
		log.info("Start generation Go Lang Api");
		URL url = GeneratorGoLangAPI.class.getResource("/" + DEFAULT_GO_API_FOLDER);

		String pkg = "it.unive.golisa.golang.util";
		List<String> classNames = new ArrayList<>();

		generateGoAPIClasses(url, pkg, classNames);
		generateGoLangAPISignatureMapper(pkg, classNames);

		log.info("End generation Go Lang Api");
	}

	private static void generateGoLangAPISignatureMapper(String pkg, List<String> classNames) {
		StringBuilder sourceCode = new StringBuilder();
		try {
			sourceCode.append("package " + pkg + ";" + "\n" + "\n");
			sourceCode.append("import java.util.Map;" + "\n");
			sourceCode.append("import java.util.Set;" + "\n");
			sourceCode.append("import java.util.HashMap;" + "\n");
			sourceCode.append("import java.util.HashSet;" + "\n" + "\n");
			for (String name : classNames)
				sourceCode.append("import " + pkg + "." + name + ";" + "\n");
			sourceCode.append("import it.unive.golisa.golang.api.signature.ConstGoLangApiSignature;" + "\n");
			sourceCode.append("import it.unive.golisa.golang.api.signature.FuncGoLangApiSignature;" + "\n");
			sourceCode.append("import it.unive.golisa.golang.api.signature.MethodGoLangApiSignature;" + "\n");
			sourceCode.append("import it.unive.golisa.golang.api.signature.TypeGoLangApiSignature;" + "\n");
			sourceCode.append("import it.unive.golisa.golang.api.signature.VarGoLangApiSignature;" + "\n" + "\n");
			sourceCode.append("/**" + "\n");
			sourceCode.append("* Auto-generated by GoLiSA build" + "\n");
			sourceCode.append("*/" + "\n");
			sourceCode.append("public class GoLangAPISignatureMapper{" + "\n");
			sourceCode.append("\t" + "private final Map<String, Set<ConstGoLangApiSignature>> mapConst;" + "\n");
			sourceCode.append("\t" + "private final Map<String, Set<FuncGoLangApiSignature>> mapFunc;" + "\n");
			sourceCode.append("\t" + "private final Map<String, Set<MethodGoLangApiSignature>> mapMethod;" + "\n");
			sourceCode.append("\t" + "private final Map<String, Set<TypeGoLangApiSignature>> mapType;" + "\n");
			sourceCode.append("\t" + "private final Map<String, Set<VarGoLangApiSignature>> mapVar;" + "\n");
			sourceCode.append("\t" + "private final Set<String> pkgs;" + "\n" + "\n");
			sourceCode.append("\t" + "private static GoLangAPISignatureMapper instance = null;" + "\n" + "\n");
			sourceCode.append("\t" + "// singleton pattern" + "\n");
			sourceCode
					.append("\t" + "public static synchronized GoLangAPISignatureMapper getGoApiSignatures(){" + "\n");
			sourceCode.append("\t" + "\t" + "if (instance == null)" + "\n");
			sourceCode.append("\t" + "\t" + "\t" + "instance = new GoLangAPISignatureMapper();" + "\n");
			sourceCode.append("\t" + "\t" + "return instance;" + "\n");
			sourceCode.append("\t" + "}" + "\n" + "\n");

			sourceCode.append("\t" + "private GoLangAPISignatureMapper(){" + "\n");
			sourceCode.append("\t" + "\t" + "pkgs = new HashSet<>();" + "\n");
			sourceCode.append("\t" + "\t" + "mapConst = new HashMap<String,Set<ConstGoLangApiSignature>>();" + "\n");
			sourceCode.append("\t" + "\t" + "mapFunc = new HashMap<String,Set<FuncGoLangApiSignature>>();" + "\n");
			sourceCode.append("\t" + "\t" + "mapMethod = new HashMap<String,Set<MethodGoLangApiSignature>>();" + "\n");
			sourceCode.append("\t" + "\t" + "mapType = new HashMap<String,Set<TypeGoLangApiSignature>>();" + "\n");
			sourceCode.append("\t" + "\t" + "mapVar = new HashMap<String,Set<VarGoLangApiSignature>>();" + "\n" + "\n");
			sourceCode.append("\t" + "\t" + "build();" + "\n");
			sourceCode.append("\t" + "}" + "\n" + "\n");
			sourceCode.append("\t" + "public Set<String> getPackages(){" + "\n");
			sourceCode.append("\t" + "\t" + "return pkgs;" + "\n");
			sourceCode.append("\t" + "}" + "\n" + "\n");
			sourceCode.append("\t" + "public Map<String, Set<ConstGoLangApiSignature>> getMapConst(){" + "\n");
			sourceCode.append("\t" + "\t" + "return mapConst;" + "\n");
			sourceCode.append("\t" + "}" + "\n" + "\n");
			sourceCode.append("\t" + "public Map<String, Set<FuncGoLangApiSignature>> getMapFunc(){" + "\n");
			sourceCode.append("\t" + "\t" + "return mapFunc;" + "\n");
			sourceCode.append("\t" + "}" + "\n" + "\n");
			sourceCode.append("\t" + "public Map<String, Set<MethodGoLangApiSignature>> getMapMethod(){" + "\n");
			sourceCode.append("\t" + "\t" + "return mapMethod;" + "\n");
			sourceCode.append("\t" + "}" + "\n" + "\n");
			sourceCode.append("\t" + "public Map<String, Set<TypeGoLangApiSignature>> getMapType(){" + "\n");
			sourceCode.append("\t" + "\t" + "return mapType;" + "\n");
			sourceCode.append("\t" + "}" + "\n" + "\n");
			sourceCode.append("\t" + "public Map<String, Set<VarGoLangApiSignature>> getMapVar(){" + "\n");
			sourceCode.append("\t" + "\t" + "return mapVar;" + "\n");
			sourceCode.append("\t" + "}" + "\n" + "\n");
			sourceCode.append("\t" + buildMapper(classNames) + "\n" + "\n");

			sourceCode.append("}");

			FileUtils.write(new File("C:\\Users\\OlivieriL\\Desktop\\src-gen\\GoLangAPISignatureMapper.java"),
					sourceCode.toString());
		} catch (IOException e) {
			log.error("Unable to generate GoLangAPISignatureMapper", e);
		}
	}

	private static String buildMapper(List<String> classNames) {
		StringBuilder res = new StringBuilder();
		String tabs = "\t" + "\t";
		res.append("private void build(){" + "\n");
		for (int i = 0; i < classNames.size(); i++) {
			res.append(tabs + classNames.get(i) + " g" + i + " = new " + classNames.get(i) + "();" + "\n" + "\n");
			res.append(tabs + "pkgs.addAll(" + "g" + i + ".getPackages());" + "\n");
			res.append(tabs + "mapConst.putAll(" + "g" + i + ".getMapConst());" + "\n");
			res.append(tabs + "mapFunc.putAll(" + "g" + i + ".getMapFunc());" + "\n");
			res.append(tabs + "mapMethod.putAll(" + "g" + i + ".getMapMethod());" + "\n");
			res.append(tabs + "mapType.putAll(" + "g" + i + ".getMapType());" + "\n");
			res.append(tabs + "mapVar.putAll(" + "g" + i + ".getMapVar());" + "\n" + "\n");
		}
		res.append("\t" + "}" + "\n" + "\n");

		return res.toString();
	}

	private static void generateGoAPIClasses(URL url, String pkg, List<String> classNames) {

		for (File file : new File(url.getFile()).listFiles()) {
			if (FilenameUtils.isExtension(file.getName(), "txt"))
				try {
					Map<? extends String,
							? extends Set<GoLangApiSignature>> tmp = parseGoAPIFile(new FileInputStream(file));
					String className = FilenameUtils.removeExtension(StringUtils.capitalize(file.getName()))
							.replace(".", "_").replace("-", "_");
					classNames.add(className);

					StringBuilder sourceCode = new StringBuilder();

					sourceCode.append("package " + pkg + ";" + "\n" + "\n");
					sourceCode.append("import java.util.Map;" + "\n");
					sourceCode.append("import java.util.Set;" + "\n");
					sourceCode.append("import java.util.HashMap;" + "\n");
					sourceCode.append("import java.util.HashSet;" + "\n" + "\n");
					sourceCode.append("import it.unive.golisa.golang.api.signature.ConstGoLangApiSignature;" + "\n");
					sourceCode.append("import it.unive.golisa.golang.api.signature.FuncGoLangApiSignature;" + "\n");
					sourceCode.append("import it.unive.golisa.golang.api.signature.MethodGoLangApiSignature;" + "\n");
					sourceCode.append("import it.unive.golisa.golang.api.signature.TypeGoLangApiSignature;" + "\n");
					sourceCode
							.append("import it.unive.golisa.golang.api.signature.VarGoLangApiSignature;" + "\n" + "\n");
					sourceCode.append("/**" + "\n");
					sourceCode.append("* Auto-generated by GoLiSA build" + "\n");
					sourceCode.append("*/" + "\n");
					sourceCode.append("public class " + className + " {" + "\n");
					sourceCode
							.append("\t" + "private final Map<String, Set<ConstGoLangApiSignature>> mapConst;" + "\n");
					sourceCode.append("\t" + "private final Map<String, Set<FuncGoLangApiSignature>> mapFunc;" + "\n");
					sourceCode.append(
							"\t" + "private final Map<String, Set<MethodGoLangApiSignature>> mapMethod;" + "\n");
					sourceCode.append("\t" + "private final Map<String, Set<TypeGoLangApiSignature>> mapType;" + "\n");
					sourceCode.append("\t" + "private final Map<String, Set<VarGoLangApiSignature>> mapVar;" + "\n");
					sourceCode.append("\t" + "private final Set<String> pkgs;" + "\n" + "\n");
					sourceCode.append("\t" + "public " + className + "(){" + "\n");
					sourceCode.append("\t" + "\t" + "pkgs = new HashSet<>();" + "\n");
					sourceCode.append(
							"\t" + "\t" + "mapConst = new HashMap<String,Set<ConstGoLangApiSignature>>();" + "\n");
					sourceCode.append(
							"\t" + "\t" + "mapFunc = new HashMap<String,Set<FuncGoLangApiSignature>>();" + "\n");
					sourceCode.append(
							"\t" + "\t" + "mapMethod = new HashMap<String,Set<MethodGoLangApiSignature>>();" + "\n");
					sourceCode.append(
							"\t" + "\t" + "mapType = new HashMap<String,Set<TypeGoLangApiSignature>>();" + "\n");
					sourceCode.append(
							"\t" + "\t" + "mapVar = new HashMap<String,Set<VarGoLangApiSignature>>();" + "\n" + "\n");
					sourceCode.append("\t" + "\t" + "build();" + "\n");
					sourceCode.append("\t" + "}" + "\n" + "\n");
					sourceCode.append("\t" + "public Set<String> getPackages(){" + "\n");
					sourceCode.append("\t" + "\t" + "return pkgs;" + "\n");
					sourceCode.append("\t" + "}" + "\n" + "\n");
					sourceCode.append("\t" + "public Map<String, Set<ConstGoLangApiSignature>> getMapConst(){" + "\n");
					sourceCode.append("\t" + "\t" + "return mapConst;" + "\n");
					sourceCode.append("\t" + "}" + "\n" + "\n");
					sourceCode.append("\t" + "public Map<String, Set<FuncGoLangApiSignature>> getMapFunc(){" + "\n");
					sourceCode.append("\t" + "\t" + "return mapFunc;" + "\n");
					sourceCode.append("\t" + "}" + "\n" + "\n");
					sourceCode
							.append("\t" + "public Map<String, Set<MethodGoLangApiSignature>> getMapMethod(){" + "\n");
					sourceCode.append("\t" + "\t" + "return mapMethod;" + "\n");
					sourceCode.append("\t" + "}" + "\n" + "\n");
					sourceCode.append("\t" + "public Map<String, Set<TypeGoLangApiSignature>> getMapType(){" + "\n");
					sourceCode.append("\t" + "\t" + "return mapType;" + "\n");
					sourceCode.append("\t" + "}" + "\n" + "\n");
					sourceCode.append("\t" + "public Map<String, Set<VarGoLangApiSignature>> getMapVar(){" + "\n");
					sourceCode.append("\t" + "\t" + "return mapVar;" + "\n");
					sourceCode.append("\t" + "}" + "\n" + "\n");
					sourceCode.append("\t" + populate(tmp) + "\n" + "\n");

					sourceCode.append("}");

					FileUtils.write(new File("C:\\Users\\OlivieriL\\Desktop\\src-gen\\" + className + ".java"),
							sourceCode.toString());
				} catch (IOException e) {
					log.error("Unable to generate Go API file " + file.getName(), e);
				}
		}

	}

	private static String populate(Map<? extends String, ? extends Set<GoLangApiSignature>> tmp) {

		String tabs = "\t" + "\t";

		List<String> list = new ArrayList<>(); // work around limit of bytes for
												// a single method in JAVA

		StringBuilder sb = new StringBuilder();
		int count = 0;
		for (String pkg : tmp.keySet()) {
			sb.append(tabs + "pkgs.add(\"" + pkg + "\");" + "\n");
			sb.append(tabs + "mapConst.putIfAbsent(\"" + pkg + "\", new HashSet<ConstGoLangApiSignature>());" + "\n");
			sb.append(tabs + "mapFunc.putIfAbsent(\"" + pkg + "\", new HashSet<FuncGoLangApiSignature>());" + "\n");
			sb.append(tabs + "mapMethod.putIfAbsent(\"" + pkg + "\", new HashSet<MethodGoLangApiSignature>());" + "\n");
			sb.append(tabs + "mapType.putIfAbsent(\"" + pkg + "\", new HashSet<TypeGoLangApiSignature>());" + "\n");
			sb.append(
					tabs + "mapVar.putIfAbsent(\"" + pkg + "\", new HashSet<VarGoLangApiSignature>());" + "\n" + "\n");

			Iterator<GoLangApiSignature> iter = tmp.get(pkg).iterator();
			while (iter.hasNext()) {
				GoLangApiSignature next = iter.next();
				if (next instanceof ConstGoLangApiSignature) {
					ConstGoLangApiSignature cnst = (ConstGoLangApiSignature) next;
					sb.append(tabs + "mapConst.get(\"" + pkg + "\").add( new ConstGoLangApiSignature("
							+ (cnst.getPackage() != null ? "\"" + cnst.getPackage() + "\"" : "null") + ", "
							+ (cnst.getName() != null ? "\"" + cnst.getName() + "\"" : "null") + ", "
							+ (cnst.getValue() != null ? "\"" + StringEscapeUtils.escapeJava(cnst.getValue()) + "\""
									: "null")
							+ ", " + (cnst.getType() != null ? "\"" + cnst.getType() + "\"" : "null") + "));" + "\n");
				} else if (next instanceof FuncGoLangApiSignature) {
					FuncGoLangApiSignature fun = (FuncGoLangApiSignature) next;
					sb.append(tabs + "mapFunc.get(\"" + pkg + "\").add( new FuncGoLangApiSignature("
							+ (fun.getPackage() != null ? "\"" + fun.getPackage() + "\"" : "null") + ", "
							+ (fun.getName() != null ? "\"" + fun.getName() + "\"" : "null") + ", "
							+ getStringArray(fun.getParams()) + ", " + getStringArray(fun.getRet()) + "));" + "\n");
				} else if (next instanceof MethodGoLangApiSignature) {
					MethodGoLangApiSignature mtd = (MethodGoLangApiSignature) next;
					sb.append(tabs + "mapMethod.get(\"" + pkg + "\").add( new MethodGoLangApiSignature("
							+ (mtd.getPackage() != null ? "\"" + mtd.getPackage() + "\"" : "null") + ", "
							+ (mtd.getReceiver() != null ? "\"" + mtd.getReceiver() + "\"" : "null") + ", "
							+ (mtd.getName() != null ? "\"" + mtd.getName() + "\"" : "null") + ", "
							+ getStringArray(mtd.getParams()) + ", " + getStringArray(mtd.getRet()) + "));" + "\n");
				} else if (next instanceof TypeGoLangApiSignature) {
					TypeGoLangApiSignature type = (TypeGoLangApiSignature) next;
					sb.append(tabs + "mapType.get(\"" + pkg + "\").add( new TypeGoLangApiSignature("
							+ (type.getPackage() != null ? "\"" + type.getPackage() + "\"" : "null") + ", "
							+ (type.getFullTypeSignature() != null ? "\"" + type.getFullTypeSignature() + "\"" : "null")
							+ "));" + "\n");
				} else if (next instanceof VarGoLangApiSignature) {
					VarGoLangApiSignature var = (VarGoLangApiSignature) next;
					sb.append(tabs + "mapVar.get(\"" + pkg + "\").add( new VarGoLangApiSignature("
							+ (var.getPackage() != null ? "\"" + var.getPackage() + "\"" : "null") + ", "
							+ (var.getName() != null ? "\"" + var.getName() + "\"" : "null") + ", "
							+ (var.getType() != null ? "\"" + var.getType() + "\"" : "null") + "));" + "\n");
				} else
					throw new UnsupportedOperationException("Class " + next.getClass() + " not handled!");

				if (!iter.hasNext())
					sb.append(tabs + "\n");

				count++;
				if (count > 500) {
					list.add(sb.toString());
					sb = new StringBuilder();
					count = 0;
				}
			}

		}

		if (count > 0)
			list.add(sb.toString());

		StringBuilder res = new StringBuilder();

		res.append("private void build(){" + "\n");
		for (int i = 0; i < list.size(); i++)
			res.append(tabs + "build" + i + "();" + "\n");
		res.append("\t" + "}" + "\n" + "\n");

		for (int i = 0; i < list.size(); i++) {
			res.append("\t" + "private void build" + i + "(){" + "\n");
			res.append(list.get(i));
			res.append("\t" + "}" + "\n" + "\n");
		}

		return res.toString();
	}

	private static String getStringArray(String[] params) {

		if (params == null)
			return "null";
		String s = "new String[]{";
		for (int i = 0; i < params.length; i++) {
			s += "\"" + params[i] + "\"";
			if (i < params.length - 1)
				s += " ,";
		}
		s += "}";
		return s;
	}

	private static Map<? extends String, ? extends Set<GoLangApiSignature>> parseGoAPIFile(InputStream inputStream)
			throws IOException {
		List<String> lines = new ArrayList<>();
		BufferedReader br = new BufferedReader(new InputStreamReader(inputStream));
		String s;
		while ((s = br.readLine()) != null)
			lines.add(s);
		br.close();

		Map<String, Set<GoLangApiSignature>> tmp = new HashMap<>();
		boolean comment = false;
		for (String line : lines) {
			if (line.contains("/*"))
				comment = true;
			else if (line.contains("*/"))
				comment = false;

			if (!comment) {
				line = cleanLine(line);
				String pkg = parsePackage(line);
				if (pkg != null) {
					GoLangApiSignature signature = parseSignature(line);
					if (signature != null) {
						tmp.putIfAbsent(pkg, new HashSet<>());
						tmp.get(pkg).add(signature);
					}
				}
			}
		}

		return reduceMap(tmp);

	}

	private static String parsePackage(String s) {
		Pattern p = Pattern.compile("pkg (.*), (func|method|type|var|const)");
		Matcher m = p.matcher(s);

		if (m.find())
			return m.group(1);
		return null;
	}

	/**
	 * Information of type struct and const are write some times on multiple
	 * lines in the files. This method allows to merge those information
	 * reducing the dimension of map
	 * 
	 * @param map the map to reduce
	 * 
	 * @return the reduced map
	 */
	private static Map<? extends String, ? extends Set<GoLangApiSignature>> reduceMap(
			Map<String, Set<GoLangApiSignature>> map) {

		// TODO: merge type and const
		return map;
	}

	/**
	 * Clean a line from comments
	 * 
	 * @param line the line to clean
	 * 
	 * @return the cleaned line
	 */
	private static String cleanLine(String line) {
		int index = StringUtils.indexOf(line, "//");
		return index == -1 ? line : line.substring(0, index);
	}

	private final static String regex_func = "pkg (.*), func ([a-zA-Z0-9_]*)\\((.*?)\\) ?(.*)";
	private final static String regex_method = "pkg (.*), method (\\(.*?\\)) ([a-zA-Z0-9_]*)\\((.*?)\\) ?(.*)";
	private final static String regex_const = "pkg (.*), const ([^=]*) [= ]?(.*)";
	private final static String regex_var = "pkg (.*), var (.*) (.*)";
	private final static String regex_type = "pkg (.*), type (.*)";

	private static GoLangApiSignature parseSignature(String line) {

		if (line.matches(regex_method))
			return parseMethodGoLangApiSignature(line);
		else if (line.matches(regex_func))
			return parseFuncGoLangApiSignature(line);
		else if (line.matches(regex_const))
			return parseConstGoLangApiSignature(line);
		else if (line.matches(regex_var))
			return parseVarGoLangApiSignature(line);
		else if (line.matches(regex_type))
			return parseTypeGoLangApiSignature(line);

		throw new UnsupportedOperationException("Unable to parse correct family of GoLang API");
	}

	private static GoLangApiSignature parseTypeGoLangApiSignature(String s) {
		Pattern p = Pattern.compile(regex_type);
		Matcher m = p.matcher(s);
		if (m.matches())
			return new TypeGoLangApiSignature(m.group(1), m.group(2));

		log.error("Unable to parse the following type: \"" + s + "\"");
		return null;
	}

	private static GoLangApiSignature parseVarGoLangApiSignature(String s) {
		Pattern p = Pattern.compile(regex_var);
		Matcher m = p.matcher(s);
		if (m.matches())
			return new VarGoLangApiSignature(m.group(1), m.group(2), m.group(3));

		log.error("Unable to parse the following var: \"" + s + "\"");
		return null;
	}

	private static GoLangApiSignature parseConstGoLangApiSignature(String s) {
		Pattern p = Pattern.compile(regex_const);
		Matcher m = p.matcher(s);
		if (m.matches())
			if (s.contains("="))
				return new ConstGoLangApiSignature(m.group(1), m.group(2), m.group(3), null);
			else
				return new ConstGoLangApiSignature(m.group(1), m.group(2), null, m.group(3));

		log.error("Unable to parse the following const: \"" + s + "\"");
		return null;
	}

	private static GoLangApiSignature parseMethodGoLangApiSignature(String s) {
		Pattern p = Pattern.compile(regex_method);
		Matcher m = p.matcher(s);
		if (m.matches())
			return new MethodGoLangApiSignature(m.group(1), m.group(2).replace("(", "").replace(")", ""), m.group(3),
					m.group(4).contains(",") ? m.group(4).split(",") : new String[] { m.group(4) },
					m.group(5).contains(",") ? m.group(5).replace("(", "").replace(")", "").split(",")
							: new String[] { m.group(5) });

		log.error("Unable to parse the following method: \"" + s + "\"");
		return null;
	}

	private static GoLangApiSignature parseFuncGoLangApiSignature(String s) {
		Pattern p = Pattern.compile(regex_func);
		Matcher m = p.matcher(s);
		if (m.matches())
			return new FuncGoLangApiSignature(m.group(1), m.group(2),
					m.group(3).contains(",") ? m.group(3).split(",") : new String[] { m.group(3) },
					m.group(4).contains(",") ? m.group(4).replace("(", "").replace(")", "").split(",")
							: new String[] { m.group(4) });

		log.error("Unable to parse the following function: \"" + s + "\"");
		return null;
	}

}
